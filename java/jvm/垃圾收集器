<mxfile host="app.diagrams.net" modified="2021-09-09T08:05:32.938Z" agent="5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36" etag="uUTgJrIv2DmybnOkadrU" version="15.1.2" type="github">
  <diagram id="dV8cyQQ65th9yz1UQDVJ" name="Page-1">
    <mxGraphModel dx="946" dy="521" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-1" value="" style="shape=image;verticalLabelPosition=bottom;labelBackgroundColor=#ffffff;verticalAlign=top;aspect=fixed;imageAspect=0;image=http://image.clickear.top/20210908163105.png;" vertex="1" parent="1">
          <mxGeometry x="30" y="410" width="874.14" height="390" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-2" style="edgeStyle=entityRelationEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fontSize=16;" edge="1" parent="1" source="Q7dUhuoePkNYFKDqM1IS-6" target="Q7dUhuoePkNYFKDqM1IS-7">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-3" style="edgeStyle=entityRelationEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;fontSize=16;" edge="1" parent="1" source="Q7dUhuoePkNYFKDqM1IS-6" target="Q7dUhuoePkNYFKDqM1IS-8">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-4" style="edgeStyle=entityRelationEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;fontSize=16;" edge="1" parent="1" source="Q7dUhuoePkNYFKDqM1IS-6" target="Q7dUhuoePkNYFKDqM1IS-9">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-5" style="edgeStyle=entityRelationEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fontSize=16;" edge="1" parent="1" source="Q7dUhuoePkNYFKDqM1IS-6" target="Q7dUhuoePkNYFKDqM1IS-10">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-6" value="垃圾收集算法" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="80" y="190" width="110" height="50" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-7" value="分代收集理论" style="rounded=0;whiteSpace=wrap;html=1;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="290" y="90" width="130" height="40" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-8" value="标记清除法" style="rounded=0;whiteSpace=wrap;html=1;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="290" y="153" width="130" height="40" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-9" value="标记复制法" style="rounded=0;whiteSpace=wrap;html=1;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="290" y="217" width="130" height="40" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-10" value="标记压缩法" style="rounded=0;whiteSpace=wrap;html=1;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="290" y="280" width="130" height="40" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-11" value="&lt;p&gt;&lt;b&gt;分代收集理论&lt;/b&gt;：&lt;span style=&quot;font-weight: normal&quot;&gt;&lt;font style=&quot;font-size: 14px&quot;&gt;就是根据对象存活周期不同将内存分为几块，例如java堆分为新生代和老年代，新生代采用复制算法，老年代采用标记整理或者标记清除算法&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="440" y="63" width="510" height="90" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-12" value="&lt;p&gt;&lt;b&gt;标记清除法(老生代)：&lt;/b&gt;&lt;font style=&quot;font-size: 13px&quot;&gt;算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：1.效率问题&amp;nbsp; (如果需要标记的对象太多，效率不高)2.空间问题（标记清除后会产生大量不连续的碎片）&lt;/font&gt;&lt;br&gt;&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="440" y="130" width="510" height="120" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-13" value="&lt;p&gt;&lt;b&gt;标记复制法（新生代）：&lt;/b&gt;&lt;font style=&quot;font-size: 14px&quot;&gt;将内存分为两块大小相同区域，当一块区域内存填满，将存活对象复制到另外一块区域，再清除这块区域。优点：效率高，清理完成是连续空间，缺点：浪费内存&lt;/font&gt;&lt;br&gt;&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="440" y="320" width="510" height="90" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-14" value="&lt;p&gt;&lt;b&gt;标记压缩法：&lt;/b&gt;&lt;font style=&quot;font-size: 14px&quot;&gt;标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。整理为一段连续的空间碎片&lt;/font&gt;&lt;br&gt;&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="440" y="240" width="510" height="90" as="geometry" />
        </mxCell>
        <mxCell id="Q7dUhuoePkNYFKDqM1IS-15" value="&lt;h1&gt;Heading&lt;/h1&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontSize=16;" vertex="1" parent="1">
          <mxGeometry x="70" y="1020" width="190" height="120" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
